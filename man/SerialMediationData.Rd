% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classes.R
\name{SerialMediationData}
\alias{SerialMediationData}
\title{SerialMediationData S7 Class}
\usage{
SerialMediationData(
  a_path = integer(0),
  d_path = integer(0),
  b_path = integer(0),
  c_prime = integer(0),
  estimates = integer(0),
  vcov = (function (.data) 
 {
    
    stop(sprintf("S3 class <\%s> doesn't have a constructor", class[[1]]), call. =
    FALSE)
 })(),
  sigma_mediators = integer(0),
  sigma_y = integer(0),
  treatment = character(0),
  mediators = character(0),
  outcome = character(0),
  mediator_predictors = list(),
  outcome_predictors = character(0),
  data = (function (.data = list(), row.names = NULL) 
 {
     if (is.null(row.names)) {

            list2DF(.data)
     }
     else {
         out <- list2DF(.data,
    length(row.names))
         attr(out, "row.names") <- row.names
         out
     }

    })(),
  n_obs = integer(0),
  converged = logical(0),
  source_package = character(0)
)
}
\arguments{
\item{a_path}{Numeric scalar: effect of treatment on first mediator (X -> M1)}

\item{d_path}{Numeric vector: sequential mediator-to-mediator effects
\itemize{
\item For 2 mediators (X -> M1 -> M2 -> Y): scalar d21 (M1 -> M2)
\item For 3 mediators (X -> M1 -> M2 -> M3 -> Y): c(d21, d32)
\item For k mediators: vector of length (k-1)
}}

\item{b_path}{Numeric scalar: effect of last mediator on outcome (Mk -> Y)}

\item{c_prime}{Numeric scalar: direct effect of treatment on outcome (X -> Y)}

\item{estimates}{Numeric vector: all parameter estimates}

\item{vcov}{Numeric matrix: variance-covariance matrix of estimates}

\item{sigma_mediators}{Numeric vector or NULL: residual SDs for mediator models.
Length should match number of mediators. First element is residual SD for M1 model,
second element for M2 model, etc.}

\item{sigma_y}{Numeric scalar or NULL: residual SD for outcome model}

\item{treatment}{Character scalar: name of treatment variable}

\item{mediators}{Character vector: names of mediators in sequential order.
First element is M1, second element is M2, etc.}

\item{outcome}{Character scalar: name of outcome variable}

\item{mediator_predictors}{List of character vectors: predictor names for each mediator model.
First list element contains predictors for M1 (typically just "X"),
second element contains predictors for M2 (typically c("X", "M1")), etc.}

\item{outcome_predictors}{Character vector: predictor names in outcome model}

\item{data}{Data frame or NULL: original data}

\item{n_obs}{Integer scalar: number of observations}

\item{converged}{Logical scalar: whether all models converged}

\item{source_package}{Character scalar: package/engine used for fitting}
}
\value{
A SerialMediationData S7 object
}
\description{
S7 class for serial mediation models where the effect flows through
multiple mediators in sequence: X -> M1 -> M2 -> ... -> Mk -> Y.

This class supports serial mediation chains of any length, from simple
two-mediator models (product-of-three: a * d * b) to complex chains
with many mediators (product-of-k).
}
\details{
\subsection{Serial Mediation Structure}{

Serial mediation models the indirect effect flowing through a sequence of
mediators. The total indirect effect is the product of all path coefficients:
\itemize{
\item \strong{2 mediators (product-of-three)}: Indirect = a * d * b
\item \strong{3 mediators (product-of-four)}: Indirect = a * d21 * d32 * b
\item \strong{k mediators (product-of-k+1)}: Indirect = a * d21 * d32 * ... * d(k,k-1) * b
}
}

\subsection{Path Notation}{
\itemize{
\item \code{a}: Treatment -> First mediator (X -> M1)
\item \code{d21}: First -> Second mediator (M1 -> M2)
\item \code{d32}: Second -> Third mediator (M2 -> M3)
\item \code{dji}: Previous mediator -> Current mediator
\item \code{b}: Last mediator -> Outcome (Mk -> Y)
\item \verb{c'}: Direct effect (X -> Y, controlling for all mediators)
}
}

\subsection{Extensibility}{

This class is designed to handle serial chains of any length:
\itemize{
\item Minimal case: 2 mediators (length(d_path) = 1)
\item No upper limit on chain length
\item Validator ensures consistency between mediators and paths
}
}
}
\examples{
\dontrun{
# Two-mediator serial mediation (X -> M1 -> M2 -> Y)
# Product-of-three: a * d * b
serial_data <- SerialMediationData(
  a_path = 0.5,       # X -> M1
  d_path = 0.4,       # M1 -> M2 (scalar for 2 mediators)
  b_path = 0.3,       # M2 -> Y
  c_prime = 0.1,      # X -> Y (direct)
  estimates = c(0.5, 0.4, 0.3, 0.1),
  vcov = diag(4) * 0.01,
  sigma_mediators = c(1.0, 1.1),  # SD for M1, M2 models
  sigma_y = 1.2,
  treatment = "X",
  mediators = c("M1", "M2"),
  outcome = "Y",
  mediator_predictors = list(
    c("X"),           # M1 ~ X
    c("X", "M1")      # M2 ~ X + M1
  ),
  outcome_predictors = c("X", "M1", "M2"),  # Y ~ X + M1 + M2
  data = NULL,
  n_obs = 100L,
  converged = TRUE,
  source_package = "lavaan"
)

# Three-mediator serial mediation (X -> M1 -> M2 -> M3 -> Y)
# Product-of-four: a * d21 * d32 * b
serial_data_3 <- SerialMediationData(
  a_path = 0.5,           # X -> M1
  d_path = c(0.4, 0.35),  # M1 -> M2, M2 -> M3 (vector for 3 mediators)
  b_path = 0.3,           # M3 -> Y
  c_prime = 0.1,
  estimates = c(0.5, 0.4, 0.35, 0.3, 0.1),
  vcov = diag(5) * 0.01,
  sigma_mediators = c(1.0, 1.1, 1.05),  # SD for M1, M2, M3 models
  sigma_y = 1.2,
  treatment = "X",
  mediators = c("M1", "M2", "M3"),
  outcome = "Y",
  mediator_predictors = list(
    c("X"),              # M1 ~ X
    c("X", "M1"),        # M2 ~ X + M1
    c("X", "M1", "M2")   # M3 ~ X + M1 + M2
  ),
  outcome_predictors = c("X", "M1", "M2", "M3"),
  data = NULL,
  n_obs = 100L,
  converged = TRUE,
  source_package = "lavaan"
)
}

}
